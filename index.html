<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last Z Event Scheduler</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap');

        :root {
            --bg-body: #000000;
            --bg-panel: #0a0a0a;
            --bg-header: #111111;
            --border-color: #333333;
            --text-primary: #ffffff;
            --text-secondary: #888888;
            --accent-color: #00e5ff;
            --timeline-color: #ff0055;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header-container {
            padding: 12px 20px;
            background: var(--bg-body);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            z-index: 50;
            height: 60px;
        }

        .title-block h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: #fff;
        }

        .title-block p {
            margin: 2px 0 0;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        select, button {
            background: #222;
            color: white;
            border: 1px solid #444;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            font-family: 'Noto Sans JP', sans-serif;
        }
        
        button {
            background: var(--accent-color);
            color: black;
            font-weight: 700;
            border: none;
        }

        .viewport {
            flex-grow: 1;
            overflow: auto;
            position: relative;
            background: var(--bg-panel);
        }

        table {
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
        }

        th, td {
            border-right: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            padding: 0;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 40;
            background: var(--bg-header);
        }

        .sticky-col {
            position: sticky;
            left: 0;
            width: 140px;
            min-width: 140px;
            max-width: 140px;
            z-index: 45;
            background: var(--bg-panel);
            border-right: 2px solid #555;
        }

        .sticky-col.header {
            z-index: 50;
            background: var(--bg-header);
            text-align: center;
            vertical-align: middle;
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .month-header-cell {
            color: var(--accent-color);
            font-weight: 700;
            font-size: 13px;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-header);
            text-align: center;
        }

        .date-cell {
            width: 28px;
            text-align: center;
            font-size: 11px;
            color: #888;
            background: var(--bg-header);
            height: 24px;
            vertical-align: middle;
        }
        
        .day-cell {
            width: 28px;
            text-align: center;
            font-size: 10px;
            color: #555;
            height: 20px;
            vertical-align: middle;
            background: var(--bg-header);
        }

        .group-row td {
            background: #151515;
            padding: 6px 10px;
            font-size: 11px;
            font-weight: 700;
            color: #aaa;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            left: 0; 
            z-index: 30;
        }

        .event-row { height: 32px; }

        .event-name {
            font-size: 11px;
            color: #eee;
            padding: 0 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            text-align: center;
        }

        .grid-cell {
            background: var(--bg-panel);
            position: relative;
        }
        
        .grid-cell:hover { background: #111; }

        .event-bar {
            position: absolute;
            top: 4px;
            bottom: 4px;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            cursor: pointer;
            z-index: 10;
        }

        .event-bar:hover {
            filter: brightness(1.3);
            z-index: 20;
        }
        
        .tooltip {
            visibility: hidden;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-5px);
            background: rgba(0,0,0,0.95);
            border: 1px solid #444;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            white-space: pre;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            min-width: 150px;
        }
        
        .event-bar:hover .tooltip { visibility: visible; }

        #timeline {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--timeline-color);
            box-shadow: 0 0 10px var(--timeline-color);
            z-index: 100;
            pointer-events: none;
            display: none;
        }
        
        #timeline::after {
            content: '';
            position: absolute;
            top: 0;
            left: -4px;
            width: 10px;
            height: 10px;
            background: var(--timeline-color);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--timeline-color);
        }

        @media (max-width: 768px) {
            .sticky-col { width: 100px; min-width: 100px; }
            .event-name { font-size: 10px; }
            .date-cell, .day-cell { width: 24px; }
        }
    </style>
</head>
<body>
    <div class="header-container">
        <div class="title-block">
            <h1>Last Z Scheduler</h1>
            <p id="rangeDisplay">Loading...</p>
        </div>
        <div class="controls">
            <select id="startMonthSelect"></select>
            <button onclick="goToNow()">今日</button>
        </div>
    </div>

    <div class="viewport" id="viewport">
        <div id="timeline"></div>
        <table id="calendarTable">
            <thead id="calendarHeader"></thead>
            <tbody id="calendarBody"></tbody>
        </table>
    </div>

    <script>
        const groups = [
            {
                title: '週次イベント',
                events: [
                    { name: '幸福自選宝庫', color: 'linear-gradient(90deg, #00f260, #0575e6)', startDate: '2026-01-16', startTime: '11:00', endDate: '2026-01-23', endTime: '10:59', cycle: 28 },
                    { name: 'ラッキー抽選', color: 'linear-gradient(90deg, #4facfe, #00f2fe)', startDate: '2026-01-23', startTime: '11:00', endDate: '2026-01-30', endTime: '10:59', cycle: 28 },
                    { name: '弾丸のやつ', color: 'linear-gradient(90deg, #43e97b, #38f9d7)', startDate: '2026-01-30', startTime: '11:00', endDate: '2026-02-06', endTime: '10:59', cycle: 28 },
                    { name: 'ラッキー商店', color: 'linear-gradient(90deg, #fa709a, #fee140)', startDate: '2026-02-06', startTime: '11:00', endDate: '2026-02-13', endTime: '10:59', cycle: 28 }
                ]
            },
            {
                title: 'SvS（準決勝）',
                events: [
                    { name: 'SvS侵略権争い', color: 'linear-gradient(90deg, #f093fb, #f5576c)', startDate: '2026-01-11', startTime: '11:00', endDate: '2026-01-17', endTime: '10:59', cycle: 28 },
                    { name: 'SvS本戦', color: 'linear-gradient(90deg, #ff9a9e, #fecfef)', startDate: '2026-01-17', startTime: '23:00', endDate: '2026-01-18', endTime: '03:00', cycle: 28 }
                ]
            },
            {
                title: 'SvS（決勝）',
                events: [
                    { name: 'SvS侵略権争い', color: 'linear-gradient(90deg, #89f7fe, #66a6ff)', startDate: '2026-01-18', startTime: '11:00', endDate: '2026-01-24', endTime: '10:59', cycle: 28 },
                    { name: 'SvS本戦', color: 'linear-gradient(90deg, #cd9cf2, #f6f3ff)', startDate: '2026-01-24', startTime: '23:00', endDate: '2026-01-25', endTime: '03:00', cycle: 28 }
                ]
            }
        ];

        function parseDate(dStr, tStr) {
            const [y, m, d] = dStr.split('-').map(Number);
            const [hr, min] = tStr.split(':').map(Number);
            return new Date(y, m-1, d, hr, min);
        }

        function getOccurrences(evt, startBound, endBound) {
            const occs = [];
            const eStart = parseDate(evt.startDate, evt.startTime);
            const dur = parseDate(evt.endDate, evt.endTime) - eStart;
            const cycleMs = evt.cycle * 86400000;
            
            let curr = new Date(eStart);
            while (curr.getTime() + dur < startBound.getTime()) {
                curr = new Date(curr.getTime() + cycleMs);
            }
            while (curr < endBound) {
                const end = new Date(curr.getTime() + dur);
                if (end > startBound) {
                    occs.push({ ...evt, start: new Date(curr), end: end });
                }
                curr = new Date(curr.getTime() + cycleMs);
            }
            return occs;
        }

        const startMonthSelect = document.getElementById('startMonthSelect');
        for (let i = 0; i < 12; i++) {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = new Date(2026, i, 1).toLocaleString('ja-JP', {month:'long', year:'numeric'});
            startMonthSelect.appendChild(opt);
        }

        function render(startMonthIdx) {
            const year = 2026;
            const monthsToRender = 3;
            const monthConfigs = [];
            let totalDays = 0;

            for (let i = 0; i < monthsToRender; i++) {
                let m = startMonthIdx + i;
                let y = year;
                if (m > 11) { m -= 12; y++; }
                
                const days = new Date(y, m+1, 0).getDate();
                monthConfigs.push({ year: y, month: m, days: days, startDayOffset: totalDays });
                totalDays += days;
            }

            // Define precise view boundaries
            const viewStart = new Date(monthConfigs[0].year, monthConfigs[0].month, 1, 0, 0, 0);
            const lastM = monthConfigs[monthConfigs.length-1];
            // End of the last day (23:59:59.999)
            const viewEnd = new Date(lastM.year, lastM.month, lastM.days, 23, 59, 59, 999);

            document.getElementById('rangeDisplay').textContent = 
                `${viewStart.toLocaleString('ja-JP',{month:'long'})} - ${viewEnd.toLocaleString('ja-JP',{month:'long', year:'numeric'})}`;

            const thead = document.getElementById('calendarHeader');
            const tbody = document.getElementById('calendarBody');
            thead.innerHTML = '';
            tbody.innerHTML = '';

            // 1. Month Row
            const rowM = document.createElement('tr');
            const corner = document.createElement('th');
            corner.className = 'sticky-col header';
            corner.textContent = 'イベント';
            corner.rowSpan = 3;
            rowM.appendChild(corner);

            monthConfigs.forEach(cfg => {
                const th = document.createElement('th');
                th.className = 'month-header-cell';
                th.colSpan = cfg.days;
                th.textContent = new Date(cfg.year, cfg.month).toLocaleString('ja-JP', {month:'long'});
                rowM.appendChild(th);
            });
            thead.appendChild(rowM);

            // 2. Date Row
            const rowD = document.createElement('tr');
            monthConfigs.forEach(cfg => {
                for(let d=1; d<=cfg.days; d++) {
                    const th = document.createElement('th');
                    th.className = 'date-cell';
                    th.textContent = d;
                    rowD.appendChild(th);
                }
            });
            thead.appendChild(rowD);

            // 3. Weekday Row
            const rowW = document.createElement('tr');
            const daysJP = ['日','月','火','水','木','金','土'];
            monthConfigs.forEach(cfg => {
                for(let d=1; d<=cfg.days; d++) {
                    const date = new Date(cfg.year, cfg.month, d);
                    const th = document.createElement('th');
                    th.className = 'day-cell';
                    th.textContent = daysJP[date.getDay()];
                    if (date.getDay() === 0 || date.getDay() === 6) th.style.color = '#555';
                    rowW.appendChild(th);
                }
            });
            thead.appendChild(rowW);

            // 4. Body
            groups.forEach(grp => {
                const rowG = document.createElement('tr');
                rowG.className = 'group-row';
                const tdG = document.createElement('td');
                tdG.className = 'sticky-col';
                tdG.textContent = grp.title;
                rowG.appendChild(tdG);
                
                const fillTd = document.createElement('td');
                fillTd.colSpan = totalDays;
                fillTd.style.background = '#111';
                fillTd.style.borderBottom = '1px solid #333';
                rowG.appendChild(fillTd);
                tbody.appendChild(rowG);

                grp.events.forEach(evt => {
                    const row = document.createElement('tr');
                    row.className = 'event-row';
                    
                    const nameTd = document.createElement('td');
                    nameTd.className = 'sticky-col';
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'event-name';
                    nameDiv.textContent = evt.name;
                    nameTd.appendChild(nameDiv);
                    row.appendChild(nameTd);

                    const dayCells = [];
                    monthConfigs.forEach(cfg => {
                        for(let d=1; d<=cfg.days; d++) {
                            const td = document.createElement('td');
                            td.className = 'grid-cell';
                            row.appendChild(td);
                            dayCells.push({ td, date: new Date(cfg.year, cfg.month, d) });
                        }
                    });
                    tbody.appendChild(row);

                    const occs = getOccurrences(evt, viewStart, viewEnd);

                    occs.forEach(occ => {
                        // Calculate offset in MS from viewStart
                        const startMs = occ.start - viewStart;
                        // Calculate index in days
                        const startDayIdx = Math.floor(startMs / (1000 * 60 * 60 * 24));
                        
                        // Handle negative start (started before view)
                        let renderStartIdx = startDayIdx;
                        let renderStartTime = occ.start;
                        
                        if (startDayIdx < 0) {
                            renderStartIdx = 0;
                            renderStartTime = viewStart; 
                        }

                        if (renderStartIdx >= dayCells.length) return;

                        // Width in MS relative to view
                        const durMs = occ.end - renderStartTime;
                        const widthPct = (durMs / 86400000) * 100;

                        // Left offset within cell
                        let leftPct = 0;
                        if (renderStartIdx === startDayIdx) {
                            const mins = occ.start.getHours() * 60 + occ.start.getMinutes();
                            leftPct = (mins / 1440) * 100;
                        }

                        const cell = dayCells[renderStartIdx].td;
                        
                        const bar = document.createElement('div');
                        bar.className = 'event-bar';
                        bar.style.background = occ.color;
                        bar.style.left = `${leftPct}%`;
                        bar.style.width = `calc(${widthPct}% - 1px)`;
                        
                        const tt = document.createElement('div');
                        tt.className = 'tooltip';
                        tt.innerHTML = `<b>${occ.name}</b><br>${occ.start.toLocaleString('ja-JP')} ~ <br>${occ.end.toLocaleString('ja-JP')}`;
                        bar.appendChild(tt);
                        
                        cell.style.overflow = 'visible';
                        cell.appendChild(bar);
                    });
                });
            });

            // Pass exact view boundaries to timeline updater
            updateTimeline(viewStart, viewEnd);
        }

        function updateTimeline(viewStart, viewEnd) {
            const now = new Date(); // Real current time
            // For testing/demo logic:
            // const now = new Date(2026, 0, 27, 17, 45); 

            if (now >= viewStart && now <= viewEnd) {
                const tl = document.getElementById('timeline');
                tl.style.display = 'block';

                const totalMs = viewEnd - viewStart;
                const currentMs = now - viewStart;
                const pct = currentMs / totalMs;

                // Total width = StickyCol + (TotalDays * CellWidth)
                const stickyWidth = 140;
                // We need precise day count in this view
                const totalDays = Math.round(totalMs / (1000 * 60 * 60 * 24));
                const cellWidth = 28; // Defined in CSS
                
                // Total pixel width of the calendar grid area
                const gridWidth = totalDays * cellWidth;
                
                // Position relative to the container
                const leftPos = stickyWidth + (gridWidth * pct);
                
                tl.style.left = `${leftPos}px`;
            } else {
                document.getElementById('timeline').style.display = 'none';
            }
        }

        function goToNow() {
            const now = new Date();
            startMonthSelect.value = now.getMonth();
            render(now.getMonth());
            
            setTimeout(() => {
                const tl = document.getElementById('timeline');
                if (tl.style.display !== 'none') {
                    // Center the timeline in viewport
                    const scroll = parseInt(tl.style.left) - (window.innerWidth / 2);
                    document.getElementById('viewport').scrollTo({left: scroll, behavior: 'smooth'});
                }
            }, 100);
        }

        startMonthSelect.addEventListener('change', (e) => render(parseInt(e.target.value)));
        
        // Initial load
        goToNow();
        
        // Update timeline periodically
        setInterval(() => {
            // Re-run render with current state to update timeline pos
            // Or simpler: just call updateTimeline if view params stored
            // For simple refresh:
            if (document.getElementById('timeline').style.display !== 'none') {
                // Triggering render again is safe
                render(parseInt(startMonthSelect.value));
            }
        }, 60000);

    </script>
</body>
</html>
