<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last Z Event Scheduler</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        :root {
            --color-bg-primary: #0f172a;
            --color-bg-secondary: #1e293b;
            --color-text-primary: #f1f5f9;
            --color-text-secondary: #cbd5e1;
            --color-primary: #06b6d4;
            --color-primary-dark: #0891b2;
            --color-border: rgba(148, 163, 184, 0.1);
            --color-hover: rgba(6, 182, 212, 0.05);
            --timeline-color: #f43f5e; /* Bright red/pink for visibility */
        }

        * { box-sizing: border-box; }

        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--color-bg-primary) 0%, #1a2844 100%);
            color: var(--color-text-primary);
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 40px 24px;
        }

        .header {
            margin-bottom: 40px;
            text-align: center;
        }

        .header h1 {
            margin: 0 0 12px 0;
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 32px;
            align-items: center;
            justify-content: center;
        }

        .controls select, .controls button {
            padding: 10px 16px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 14px;
            background: var(--color-bg-secondary);
            color: var(--color-text-primary);
            cursor: pointer;
        }

        .controls button {
            background: var(--color-primary);
            border: none;
            color: white;
            font-weight: 600;
        }

        .calendar-wrapper {
            background: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            overflow-x: auto;
            position: relative; /* For absolute timeline positioning */
        }

        .calendar-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            min-width: 1400px;
            table-layout: fixed;
        }

        .calendar-table th {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1) 0%, rgba(8, 145, 178, 0.05) 100%);
            border-bottom: 1px solid var(--color-border);
            padding: 12px 4px;
            text-align: center;
            width: 45px;
            position: relative;
        }

        /* Group Header Styling */
        .group-header-row td {
            background: rgba(15, 23, 42, 0.6);
            padding: 12px 20px;
            font-weight: 700;
            color: var(--color-primary);
            font-size: 14px;
            border-bottom: 1px solid var(--color-border);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .calendar-table th.event-name-cell {
            padding: 16px 20px;
            text-align: left;
            width: 240px;
            min-width: 240px;
            background: var(--color-bg-secondary);
            z-index: 20;
            position: sticky;
            left: 0;
            border-right: 1px solid var(--color-border);
            box-shadow: 4px 0 12px rgba(0,0,0,0.1);
        }

        .calendar-table th.date-number {
            font-size: 14px;
            font-weight: 700;
            color: var(--color-primary);
        }

        .calendar-table th.day-of-week {
            font-size: 11px;
            font-weight: 500;
            color: var(--color-text-secondary);
        }

        .calendar-table td {
            border-right: 1px solid var(--color-border);
            border-bottom: 1px solid var(--color-border);
            height: 48px; /* Slightly thinner rows */
            position: relative;
            vertical-align: middle;
            padding: 0;
            overflow: visible;
        }

        .calendar-table td:hover {
            background: var(--color-hover);
        }

        .event-name-cell {
            font-size: 13px;
            font-weight: 500;
            padding: 0 20px;
            border-right: 2px solid var(--color-border);
            background: var(--color-bg-secondary);
            position: sticky;
            left: 0;
            z-index: 15;
            color: var(--color-text-secondary);
        }

        .event-bar {
            position: absolute;
            height: 24px; /* Thinner bar */
            top: 50%;
            transform: translateY(-50%);
            border-radius: 4px;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            /* No text inside */
        }

        .event-bar:hover {
            transform: translateY(calc(-50% - 2px)) scaleY(1.1);
            z-index: 100;
            filter: brightness(1.2);
        }

        /* Tooltip */
        .event-bar .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background: rgba(15, 23, 42, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            white-space: pre;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(4px);
            width: max-content;
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        .event-bar:hover .tooltip {
            opacity: 1;
        }

        /* Timeline Indicator */
        .timeline-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--timeline-color);
            z-index: 50;
            pointer-events: none;
            box-shadow: 0 0 8px var(--timeline-color);
        }

        .timeline-head {
            position: absolute;
            top: -6px;
            left: -4px;
            width: 10px;
            height: 10px;
            background: var(--timeline-color);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--timeline-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Last Z Event Scheduler</h1>
            <p id="monthTitleDisplay">Loading...</p>
        </div>

        <div class="controls">
            <select id="monthSelect">
                <!-- Javascript will populate -->
            </select>
            <button onclick="goToToday()">Today</button>
        </div>

        <div class="calendar-wrapper" id="calendarWrapper">
            <!-- Timeline Line -->
            <div id="timeline" class="timeline-indicator" style="display: none;">
                <div class="timeline-head"></div>
            </div>
            
            <table class="calendar-table" id="calendarTable"></table>
        </div>
    </div>

    <script>
        // --- 1. Event Data with Unique Colors ---
        // Each event has a specific hex color assigned manually for uniqueness.
        const groups = [
            {
                id: 'weekly',
                title: '週次イベント',
                events: [
                    { name: '幸福自選宝庫', color: '#0ea5e9', startDate: '2026-01-16', startTime: '11:00', endDate: '2026-01-23', endTime: '10:59', cycle: 28 },
                    { name: 'ラッキー抽選', color: '#22d3ee', startDate: '2026-01-23', startTime: '11:00', endDate: '2026-01-30', endTime: '10:59', cycle: 28 },
                    { name: '弾丸のやつ', color: '#2dd4bf', startDate: '2026-01-30', startTime: '11:00', endDate: '2026-02-06', endTime: '10:59', cycle: 28 },
                    { name: 'ラッキー商店', color: '#34d399', startDate: '2026-02-06', startTime: '11:00', endDate: '2026-02-13', endTime: '10:59', cycle: 28 }
                ]
            },
            {
                id: 'svs_semi',
                title: 'SvS（準決勝）',
                events: [
                    { name: 'SvS侵略権争い', color: '#f59e0b', startDate: '2026-01-11', startTime: '11:00', endDate: '2026-01-17', endTime: '10:59', cycle: 28 },
                    { name: 'SvS本戦', color: '#ea580c', startDate: '2026-01-17', startTime: '23:00', endDate: '2026-01-18', endTime: '03:00', cycle: 28 }
                ]
            },
            {
                id: 'svs_final',
                title: 'SvS（決勝）',
                events: [
                    { name: 'SvS侵略権争い', color: '#a855f7', startDate: '2026-01-18', startTime: '11:00', endDate: '2026-01-24', endTime: '10:59', cycle: 28 },
                    { name: 'SvS本戦', color: '#d946ef', startDate: '2026-01-24', startTime: '23:00', endDate: '2026-01-25', endTime: '03:00', cycle: 28 }
                ]
            }
        ];

        // Flatten events for calculation logic
        const allEventDefs = groups.flatMap(g => g.events);

        // --- 2. Date Utilities ---
        function parseDateTime(dateStr, timeStr) {
            const [year, month, day] = dateStr.split('-').map(Number);
            const [hour, minute] = timeStr.split(':').map(Number);
            return new Date(year, month - 1, day, hour, minute);
        }

        function generateOccurrences(event, rangeStart, rangeEnd) {
            const occurrences = [];
            const eventStart = parseDateTime(event.startDate, event.startTime);
            const eventEnd = parseDateTime(event.endDate, event.endTime);
            const duration = eventEnd.getTime() - eventStart.getTime();
            const cycleDays = event.cycle;

            let current = new Date(eventStart);

            // Fast forward to near range
            while (current.getTime() + duration < rangeStart.getTime()) {
                current = new Date(current.getTime() + cycleDays * 24 * 60 * 60 * 1000);
            }

            while (current <= rangeEnd) {
                const occEnd = new Date(current.getTime() + duration);
                if (occEnd >= rangeStart && current <= rangeEnd) {
                    occurrences.push({
                        ...event,
                        actualStart: new Date(current),
                        actualEnd: occEnd
                    });
                }
                current = new Date(current.getTime() + cycleDays * 24 * 60 * 60 * 1000);
            }
            return occurrences;
        }

        // --- 3. Calendar Rendering ---
        const monthSelect = document.getElementById('monthSelect');
        // Populate Select for 2026
        for(let i=0; i<12; i++) {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = new Date(2026, i, 1).toLocaleString('en-US', { month: 'long', year: 'numeric' });
            monthSelect.appendChild(opt);
        }

        function renderCalendar(monthIndex) {
            const year = 2026;
            const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
            const monthStart = new Date(year, monthIndex, 1);
            const monthEnd = new Date(year, monthIndex, daysInMonth, 23, 59, 59);

            document.getElementById('monthTitleDisplay').textContent = 
                `${new Date(year, monthIndex).toLocaleString('en-US', { month: 'long' })} ${year}`;

            const table = document.getElementById('calendarTable');
            table.innerHTML = '';

            // --- Header: Dates ---
            const dateRow = document.createElement('tr');
            const emptyCorner = document.createElement('th');
            emptyCorner.className = 'event-name-cell';
            emptyCorner.textContent = 'Event / Date';
            dateRow.appendChild(emptyCorner);

            for (let d = 1; d <= daysInMonth; d++) {
                const th = document.createElement('th');
                th.className = 'date-header date-number';
                th.textContent = d;
                dateRow.appendChild(th);
            }
            table.appendChild(dateRow);

            // --- Header: Days of Week ---
            const dayRow = document.createElement('tr');
            dayRow.appendChild(Object.assign(document.createElement('th'), { className: 'event-name-cell' })); // spacer
            const weekDays = ['日', '月', '火', '水', '木', '金', '土'];
            for (let d = 1; d <= daysInMonth; d++) {
                const dateObj = new Date(year, monthIndex, d);
                const th = document.createElement('th');
                th.className = 'date-header day-of-week';
                th.textContent = weekDays[dateObj.getDay()];
                dayRow.appendChild(th);
            }
            table.appendChild(dayRow);

            // --- Render Groups ---
            groups.forEach(group => {
                // 1. Group Title Row
                const groupRow = document.createElement('tr');
                groupRow.className = 'group-header-row';
                const titleCell = document.createElement('td');
                titleCell.colSpan = daysInMonth + 1; // Span entire width
                titleCell.textContent = group.title;
                groupRow.appendChild(titleCell);
                table.appendChild(groupRow);

                // 2. Event Rows
                group.events.forEach(eventDef => {
                    const row = document.createElement('tr');
                    
                    // Event Name
                    const nameCell = document.createElement('td');
                    nameCell.className = 'event-name-cell';
                    nameCell.textContent = eventDef.name;
                    row.appendChild(nameCell);

                    // Day Cells Container
                    const dayCells = [];
                    for (let d = 1; d <= daysInMonth; d++) {
                        const cell = document.createElement('td');
                        row.appendChild(cell);
                        dayCells.push(cell);
                    }
                    table.appendChild(row);

                    // Calculate and Draw Bars
                    // Range extended for calculation to handle spanning
                    const calcStart = new Date(monthStart); calcStart.setDate(calcStart.getDate()-30);
                    const calcEnd = new Date(monthEnd); calcEnd.setDate(calcEnd.getDate()+30);
                    
                    const occs = generateOccurrences(eventDef, calcStart, calcEnd);

                    occs.forEach(occ => {
                        // Only draw if overlap with THIS month
                        if (occ.actualEnd < monthStart || occ.actualStart > monthEnd) return;

                        // Logic: Find start day index (0-based) relative to month start
                        // If starts before month, index is 0.
                        let startIndex = 0;
                        let startOffsetPct = 0;

                        if (occ.actualStart < monthStart) {
                            startIndex = 0;
                            startOffsetPct = 0;
                        } else {
                            startIndex = occ.actualStart.getDate() - 1;
                            // Time offset
                            const minutes = occ.actualStart.getHours() * 60 + occ.actualStart.getMinutes();
                            startOffsetPct = (minutes / 1440) * 100;
                        }

                        // Calculate Width
                        // End time relative to month start vs Start time relative to month start
                        const effectiveStart = occ.actualStart < monthStart ? monthStart : occ.actualStart;
                        const effectiveEnd = occ.actualEnd > monthEnd ? monthEnd : occ.actualEnd;
                        
                        const durationMs = effectiveEnd - effectiveStart;
                        const dayMs = 24 * 60 * 60 * 1000;
                        const widthPct = (durationMs / dayMs) * 100;

                        // Draw
                        if (dayCells[startIndex]) {
                            const bar = document.createElement('div');
                            bar.className = 'event-bar';
                            bar.style.backgroundColor = occ.color;
                            bar.style.left = `${startOffsetPct}%`;
                            bar.style.width = `${widthPct}%`;

                            // Tooltip content
                            const tooltip = document.createElement('div');
                            tooltip.className = 'tooltip';
                            tooltip.innerHTML = `${occ.name}<br>${occ.actualStart.toLocaleString('ja-JP', {month:'numeric', day:'numeric', hour:'2-digit', minute:'2-digit'})} ~ ${occ.actualEnd.toLocaleString('ja-JP', {month:'numeric', day:'numeric', hour:'2-digit', minute:'2-digit'})}`;
                            bar.appendChild(tooltip);

                            dayCells[startIndex].appendChild(bar);
                        }
                    });
                });
            });

            updateTimeline(monthIndex, year, daysInMonth);
        }

        // --- 4. Timeline Logic ---
        function updateTimeline(monthIndex, year, daysInMonth) {
            const now = new Date();
            const timeline = document.getElementById('timeline');
            
            // Only show if current view is current month/year
            if (now.getMonth() === monthIndex && now.getFullYear() === year) {
                timeline.style.display = 'block';
                
                // Calculate position
                // We need to account for the "Name Column" width (240px)
                // And then find percentage across the remaining width
                
                const currentDay = now.getDate(); // 1-31
                const currentMins = now.getHours() * 60 + now.getMinutes();
                
                // There are `daysInMonth` columns.
                // Position = ( (Day-1) + (Mins/1440) ) / TotalDays
                const dayProgress = (currentDay - 1) + (currentMins / 1440);
                const totalProgress = dayProgress / daysInMonth;

                // The timeline sits inside calendar-wrapper which is `relative`.
                // But the table scrolls inside it. This is tricky with CSS sticky headers.
                // Easier approach: Put timeline inside the table or calculate pixel offset.
                // CSS Grid is best, but using Table here.
                // Let's attach timeline to the wrapper and rely on simple percentages?
                // No, because wrapper scrolls.
                
                // Correct approach for scrolling table:
                // Timeline needs to be positioned absolute relative to the TABLE content (scrolling area), 
                // but disregarding the sticky header? 
                // Actually, let's just create a special absolute div inside the first row of table or similar.
                
                // Simplest robust way: 
                // Calculate left offset: 240px (sticky col) + (totalWidth - 240px) * percentage?
                // Since table layout is fixed, we can estimate. 
                // Better: Use a dedicated container overlaid on the grid part.
                
                // For this implementation, let's inject the timeline into the TABLE itself, 
                // perhaps as a absolute div in a row that spans everything?
                
                // Let's refine the CSS left calculation dynamically:
                const nameColWidth = 240;
                // We need the width of one day column.
                // It varies.
                
                // RE-APPROACH: 
                // Put timeline in the wrapper. 
                // But update its 'left' based on the specific cell of "Today".
                
                setTimeout(() => {
                    const table = document.getElementById('calendarTable');
                    // Find header cell for today
                    const headers = table.querySelectorAll('.date-number');
                    if (headers.length >= currentDay) {
                        const todayHeader = headers[currentDay - 1]; // 0-indexed
                        
                        // Get position relative to table
                        const headerRect = todayHeader.getBoundingClientRect();
                        const tableRect = table.getBoundingClientRect();
                        
                        // Calculate offset within the day (time)
                        const dayWidth = headerRect.width;
                        const timeOffset = (currentMins / 1440) * dayWidth;
                        
                        const relativeLeft = (headerRect.left - tableRect.left) + timeOffset;

                        timeline.style.left = `${relativeLeft}px`;
                        // Timeline height should match table height
                        timeline.style.height = `${table.scrollHeight}px`;
                        
                        // Append to table so it scrolls with it
                        table.appendChild(timeline);
                    }
                }, 100);

            } else {
                timeline.style.display = 'none';
            }
        }

        function goToToday() {
            const now = new Date();
            monthSelect.value = now.getMonth();
            renderCalendar(now.getMonth());
        }

        // Init
        monthSelect.addEventListener('change', (e) => renderCalendar(parseInt(e.target.value)));
        goToToday();
        
        // Update timeline every minute
        setInterval(() => {
            const m = parseInt(monthSelect.value);
            renderCalendar(m); 
        }, 60000);

    </script>
</body>
</html>
