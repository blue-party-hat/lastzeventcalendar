<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Last Z Event Scheduler</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap');

    :root{
      --bg-body:#000;
      --bg-panel:#0a0a0a;
      --bg-header:#111;
      --border:#333;
      --text:#fff;
      --muted:#888;
      --accent:#00e5ff;
      --timeline:#ff0055;

      --shell-max:1600px;
      --shell-pad:clamp(12px,2vw,24px);

      --sticky-w:140px;
      --cell-w:30px;
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      padding:var(--shell-pad);
      font-family:'Inter','Noto Sans JP',sans-serif;
      background:var(--bg-body);
      color:var(--text);
      min-height:100vh;
      overflow:hidden;
    }

    .app-shell{
      width:min(var(--shell-max),100%);
      height:calc(100vh - (2 * var(--shell-pad)));
      margin:0 auto;
      border-radius:16px;
      overflow:hidden;
      border:1px solid #1f1f1f;
      box-shadow:0 20px 80px rgba(0,0,0,.65);
      background:#000;
      display:flex;
      flex-direction:column;
      position:relative;
    }

    .header-container{
      padding:12px 16px;
      background:#000;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      z-index:60;
      flex:0 0 auto;
    }

    .title-block h1{
      margin:0;
      font-size:16px;
      font-weight:700;
      line-height:1.1;
    }
    .title-block p{
      margin:2px 0 0;
      font-size:10px;
      color:var(--muted);
    }

    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    select, button{
      background:#222;
      color:#fff;
      border:1px solid #444;
      padding:6px 10px;
      border-radius:6px;
      font-size:11px;
      cursor:pointer;
    }

    #tzSelect{
      border-color:var(--accent);
      color:var(--accent);
      font-weight:600;
    }

    #langBtn{
      background:#111;
      border:1px solid #444;
      color:#fff;
      font-weight:800;
      min-width:44px;
    }

    #nowBtn{
      background:var(--accent);
      color:#000;
      font-weight:900;
      border:none;
    }

    .viewport{
      flex:1;
      min-height:0;
      overflow:auto;
      position:relative;
      background:var(--bg-panel);
      
      scroll-snap-type: x proximity;
      -webkit-overflow-scrolling: touch;
    }

    table{
      border-collapse:separate;
      border-spacing:0;
      table-layout:fixed;
      width:max-content;
    }
    th, td{
      border-right:1px solid var(--border);
      border-bottom:1px solid var(--border);
      padding:0;
    }

    thead{
      position:sticky;
      top:0;
      z-index:40;
      background:var(--bg-header);
    }

    .sticky-col{
      position:sticky;
      left:0;
      width:var(--sticky-w);
      min-width:var(--sticky-w);
      max-width:var(--sticky-w);
      background:var(--bg-panel);
      border-right:2px solid #555;
      z-index:45;
    }
    .sticky-col.header{
      background:var(--bg-header);
      z-index:55;
      text-align:center;
      font-size:11px;
      color:var(--muted);
      font-weight:700;
    }

    .month-header-cell{
      color:var(--accent);
      font-weight:800;
      font-size:13px;
      text-align:center;
      padding:8px 0;
      background:var(--bg-header);
      scroll-snap-align: start;
    }
    .date-cell{
      width:var(--cell-w);
      text-align:center;
      font-size:11px;
      color:#bbb;
      height:26px;
      background:var(--bg-header);
    }
    .day-cell{
      width:var(--cell-w);
      text-align:center;
      font-size:9px;
      color:#666;
      height:18px;
      background:var(--bg-header);
    }

    /* Make group titles stand out */
    .group-row td{
      background:linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%);
      padding:10px 12px;
      font-size:13px;
      font-weight:900;
      color:var(--accent);
      text-transform:uppercase;
      letter-spacing:0.5px;
      border-top:2px solid #333;
      border-bottom:2px solid #333;
      text-shadow:0 2px 8px rgba(0,229,255,0.3);
    }
    .group-row td:first-child{
      position:sticky;
      left:0;
      z-index:46;
      background:linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%);
      box-shadow:2px 0 12px rgba(0,0,0,.8);
    }

    .event-row{ height:34px; }
    .event-name{
      height:34px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:#eee;
      padding:0 10px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      text-align:center;
    }

    .grid-cell{
      position:relative;
      background:var(--bg-panel);
    }

    .event-bar{
      position:absolute;
      top:4px;
      bottom:4px;
      border-radius:4px;
      box-shadow:0 4px 12px rgba(0,0,0,.45);
      cursor:pointer;
      z-index:10;
      touch-action:manipulation;
    }
    .event-bar::before{
      content:"";
      position:absolute;
      left:-6px; right:-6px; top:-10px; bottom:-10px;
      background:transparent;
    }

    #global-tooltip{
      position:fixed;
      top:0; left:0;
      transform:translate(-50%, -100%);
      background:rgba(0,0,0,.95);
      border:1px solid #444;
      color:#fff;
      padding:10px 12px;
      border-radius:8px;
      font-size:12px;
      line-height:1.3;
      text-align:center;
      pointer-events:none;
      z-index:9999;
      opacity:0;
      transition:opacity .12s ease;
      max-width:min(340px, 90vw);
      box-shadow:0 10px 24px rgba(0,0,0,.8);
      margin-top:-10px;
    }

    #timeline{
      position:absolute;
      top:0;
      bottom:0;
      width:2px;
      background:var(--timeline);
      box-shadow:0 0 14px var(--timeline);
      z-index:80;
      pointer-events:none;
      display:none;
    }
    #timeline::after{
      content:"";
      position:absolute;
      top:0;
      left:-4px;
      width:10px;
      height:10px;
      border-radius:50%;
      background:var(--timeline);
      box-shadow:0 0 14px var(--timeline);
    }

    /* Time label on top of red line */
    #timeline-label{
      position:absolute;
      top:-30px;
      left:50%;
      transform:translateX(-50%);
      background:var(--timeline);
      color:#fff;
      padding:4px 8px;
      border-radius:4px;
      font-size:11px;
      font-weight:700;
      white-space:nowrap;
      box-shadow:0 2px 8px rgba(255,0,85,0.6);
    }

    @media (max-width: 768px){
      :root{ --sticky-w:110px; --cell-w:26px; }
      .header-container{ padding:10px 12px; }
      .group-row td{ font-size:11px; padding:8px 10px; }
      #timeline-label{ font-size:10px; padding:3px 6px; top:-28px; }
    }
  </style>
</head>

<body>
  <div class="app-shell">
    <div class="header-container">
      <div class="title-block">
        <h1 id="titleText">Last Z Scheduler</h1>
        <p id="rangeDisplay">2026 Full Year</p>
      </div>

      <div class="controls">
        <button id="langBtn" type="button">EN</button>

        <select id="tzSelect">
          <option value="Asia/Tokyo">Asia/Tokyo (JST)</option>
          <option value="UTC">UTC</option>
          <option value="America/New_York">America/New_York</option>
        </select>

        <button id="nowBtn" type="button">今日</button>
      </div>
    </div>

    <div class="viewport" id="viewport">
      <div id="timeline">
        <div id="timeline-label">00:00</div>
      </div>
      <table id="calendarTable">
        <thead id="calendarHeader"></thead>
        <tbody id="calendarBody"></tbody>
      </table>
    </div>
  </div>

  <div id="global-tooltip"></div>

  <script>
    const LS_LANG = 'lz.lang';
    const LS_TZ   = 'lz.tz';

    let uiLang = (localStorage.getItem(LS_LANG) || 'ja');
    if (uiLang !== 'ja' && uiLang !== 'en') uiLang = 'ja';

    const I18N = {
      ja: {
        title: 'Last Z Scheduler',
        eventCol: 'イベント',
        now: '今日',
        days: ['日','月','火','水','木','金','土'],
        yearRange: '2026年 全年',
        tooltipFmt: (name, start, end) => `<b>${name}</b><br>${start}<br>~<br>${end}`,
        langBtn: 'EN'
      },
      en: {
        title: 'Last Z Scheduler',
        eventCol: 'Event',
        now: 'Now',
        days: ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
        yearRange: '2026 Full Year',
        tooltipFmt: (name, start, end) => `<b>${name}</b><br>${start}<br>to<br>${end}`,
        langBtn: 'JP'
      }
    };

    const groups = [
      {
        title: '週次イベント',
        title_en: 'Weekly Events',
        events: [
          { name: '幸福自選宝庫', name_en: 'Spin the Wheel', color: 'linear-gradient(90deg, #00f260, #0575e6)', startDate: '2026-01-16', startTime: '11:00', endDate: '2026-01-23', endTime: '10:59', cycle: 28 },
          { name: 'ラッキー抽選', name_en: 'Gacha Go', color: 'linear-gradient(90deg, #4facfe, #00f2fe)', startDate: '2026-01-23', startTime: '11:00', endDate: '2026-01-30', endTime: '10:59', cycle: 28 },
          { name: '射撃場', name_en: 'Bullseye Bounty', color: 'linear-gradient(90deg, #43e97b, #38f9d7)', startDate: '2026-01-30', startTime: '11:00', endDate: '2026-02-06', endTime: '10:59', cycle: 28 },
          { name: 'ラッキー商店', name_en: 'Lucky Discounter', color: 'linear-gradient(90deg, #fa709a, #fee140)', startDate: '2026-02-06', startTime: '11:00', endDate: '2026-02-13', endTime: '10:59', cycle: 28 }
        ]
      },
      {
        title: 'SvS（準決勝）',
        title_en: 'SvS (Semifinal)',
        events: [
          { name: 'SvS侵略権争い', name_en: 'SvS Invasion Rights', color: 'linear-gradient(90deg, #f093fb, #f5576c)', startDate: '2026-01-11', startTime: '11:00', endDate: '2026-01-17', endTime: '10:59', cycle: 28 },
          { name: 'SvS本戦', name_en: 'SvS Main Battle', color: 'linear-gradient(90deg, #ff9a9e, #fecfef)', startDate: '2026-01-17', startTime: '23:00', endDate: '2026-01-18', endTime: '03:00', cycle: 28 }
        ]
      },
      {
        title: 'SvS（決勝）',
        title_en: 'SvS (Final)',
        events: [
          { name: 'SvS侵略権争い', name_en: 'SvS Invasion Rights', color: 'linear-gradient(90deg, #89f7fe, #66a6ff)', startDate: '2026-01-18', startTime: '11:00', endDate: '2026-01-24', endTime: '10:59', cycle: 28 },
          { name: 'SvS本戦', name_en: 'SvS Main Battle', color: 'linear-gradient(90deg, #cd9cf2, #f6f3ff)', startDate: '2026-01-24', startTime: '23:00', endDate: '2026-01-25', endTime: '03:00', cycle: 28 }
        ]
      }
    ];

    function getTZParts(timeZone) {
      const dtf = new Intl.DateTimeFormat('en-US', {
        timeZone,
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit',
        hour12: false
      });
      const parts = dtf.formatToParts(new Date());
      const map = {};
      for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;
      return {
        year: Number(map.year),
        month: Number(map.month),
        day: Number(map.day),
        hour: Number(map.hour),
        minute: Number(map.minute),
        second: Number(map.second)
      };
    }

    // Convert a Date object to parts in a specific timezone
    function getDatePartsInTZ(date, timeZone) {
      const dtf = new Intl.DateTimeFormat('en-US', {
        timeZone,
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit',
        hour12: false
      });
      const parts = dtf.formatToParts(date);
      const map = {};
      for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;
      return {
        year: Number(map.year),
        month: Number(map.month),
        day: Number(map.day),
        hour: Number(map.hour),
        minute: Number(map.minute),
        second: Number(map.second)
      };
    }

    function parseInternalJSTToDate(dStr, tStr) {
      return new Date(`${dStr}T${tStr}:00+09:00`);
    }

    function formatInTZ(date, timeZone) {
      const locale = (uiLang === 'ja') ? 'ja-JP' : 'en-US';
      return new Intl.DateTimeFormat(locale, {
        timeZone,
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit',
        hour12: false
      }).format(date);
    }

    function getOccurrences(evt, rangeStartJST, rangeEndJST) {
      const occs = [];
      const eStart = parseInternalJSTToDate(evt.startDate, evt.startTime);
      const eEnd = parseInternalJSTToDate(evt.endDate, evt.endTime);
      const duration = eEnd - eStart;
      const cycleMs = evt.cycle * 86400000;

      let cur = new Date(eStart);
      while (cur.getTime() + duration < rangeStartJST.getTime()) cur = new Date(cur.getTime() + cycleMs);
      while (cur < rangeEndJST) {
        const end = new Date(cur.getTime() + duration);
        if (end > rangeStartJST) occs.push({ start: new Date(cur), end });
        cur = new Date(cur.getTime() + cycleMs);
      }
      return occs;
    }

    const tooltipEl = document.getElementById('global-tooltip');
    let tooltipPinned = false;

    function showTooltipForBar(barEl) {
      tooltipEl.innerHTML = I18N[uiLang].tooltipFmt(barEl.dataset.name, barEl.dataset.start, barEl.dataset.end);

      const r = barEl.getBoundingClientRect();
      let x = r.left + r.width / 2;
      let y = r.top;

      x = Math.max(20, Math.min(window.innerWidth - 20, x));
      y = Math.max(20, y);

      tooltipEl.style.left = `${x}px`;
      tooltipEl.style.top = `${y}px`;
      tooltipEl.style.opacity = '1';
    }

    function hideTooltip() {
      tooltipEl.style.opacity = '0';
      tooltipPinned = false;
    }

    document.addEventListener('pointerdown', (e) => {
      if (!tooltipPinned) return;
      const isBar = e.target.closest && e.target.closest('.event-bar');
      if (!isBar) hideTooltip();
    });

    const tzSelect = document.getElementById('tzSelect');
    const viewport = document.getElementById('viewport');
    const timeline = document.getElementById('timeline');
    const timelineLabel = document.getElementById('timeline-label');

    const savedTZ = localStorage.getItem(LS_TZ);
    if (savedTZ) tzSelect.value = savedTZ;

    function applyUIText() {
      document.getElementById('titleText').textContent = I18N[uiLang].title;
      document.getElementById('langBtn').textContent = I18N[uiLang].langBtn;
      document.getElementById('nowBtn').textContent = I18N[uiLang].now;
      document.getElementById('rangeDisplay').textContent = I18N[uiLang].yearRange;
    }

    function getStickyWidthPx() {
      const v = getComputedStyle(document.documentElement).getPropertyValue('--sticky-w').trim();
      const px = parseFloat(v);
      return Number.isFinite(px) ? px : 140;
    }

    function updateTimeline() {
      const tz = tzSelect.value;
      const parts = getTZParts(tz);

      const cell = document.querySelector(`.date-cell[data-y="${parts.year}"][data-m="${parts.month}"][data-d="${parts.day}"]`);
      if (!cell) { 
        timeline.style.display = 'none'; 
        return; 
      }

      const seconds = parts.hour * 3600 + parts.minute * 60 + parts.second;
      const progress = seconds / 86400;

      const cellRect = cell.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      let xInViewport = (cellRect.left - vpRect.left) + (cellRect.width * progress);

      const stickyW = getStickyWidthPx();
      if (xInViewport < stickyW) xInViewport = stickyW;

      const xInContent = viewport.scrollLeft + xInViewport;

      timeline.style.display = 'block';
      timeline.style.left = `${xInContent}px`;

      // Update time label (HH:MM in 24h format)
      const hh = String(parts.hour).padStart(2, '0');
      const mm = String(parts.minute).padStart(2, '0');
      timelineLabel.textContent = `${hh}:${mm}`;
    }

    function render() {
      const tz = tzSelect.value;
      const year = 2026;

      const months = [];
      let totalDays = 0;

      for (let m = 0; m < 12; m++) {
        const days = new Date(year, m + 1, 0).getDate();
        months.push({ y: year, m, days });
        totalDays += days;
      }

      const thead = document.getElementById('calendarHeader');
      const tbody = document.getElementById('calendarBody');
      thead.innerHTML = '';
      tbody.innerHTML = '';

      const rowM = document.createElement('tr');
      const corner = document.createElement('th');
      corner.className = 'sticky-col header';
      corner.textContent = I18N[uiLang].eventCol;
      corner.rowSpan = 3;
      rowM.appendChild(corner);

      months.forEach(cfg => {
        const th = document.createElement('th');
        th.className = 'month-header-cell';
        th.colSpan = cfg.days;
        const locale = (uiLang === 'ja') ? 'ja-JP' : 'en-US';
        th.textContent = new Date(cfg.y, cfg.m, 1).toLocaleString(locale, { month: 'long' });
        rowM.appendChild(th);
      });
      thead.appendChild(rowM);

      const rowD = document.createElement('tr');
      months.forEach(cfg => {
        for (let d = 1; d <= cfg.days; d++) {
          const th = document.createElement('th');
          th.className = 'date-cell';
          th.textContent = d;
          th.dataset.y = String(cfg.y);
          th.dataset.m = String(cfg.m + 1);
          th.dataset.d = String(d);
          rowD.appendChild(th);
        }
      });
      thead.appendChild(rowD);

      const rowW = document.createElement('tr');
      const dow = I18N[uiLang].days;
      months.forEach(cfg => {
        for (let d = 1; d <= cfg.days; d++) {
          const th = document.createElement('th');
          th.className = 'day-cell';
          th.textContent = dow[new Date(cfg.y, cfg.m, d).getDay()];
          rowW.appendChild(th);
        }
      });
      thead.appendChild(rowW);

      const rangeStartJST = new Date('2026-01-01T00:00:00+09:00');
      const rangeEndJST = new Date('2026-12-31T23:59:59+09:00');

      function gridIndexForYMD(y, m1to12, d1to31) {
        let idx = 0;
        for (const cfg of months) {
          for (let dd = 1; dd <= cfg.days; dd++) {
            if (cfg.y === y && (cfg.m + 1) === m1to12 && dd === d1to31) return idx;
            idx++;
          }
        }
        return -1;
      }

      groups.forEach(grp => {
        const gr = document.createElement('tr');
        gr.className = 'group-row';

        const gName = document.createElement('td');
        gName.className = 'sticky-col';
        gName.textContent = (uiLang === 'en' ? grp.title_en : grp.title);
        gr.appendChild(gName);

        const filler = document.createElement('td');
        filler.colSpan = totalDays;
        gr.appendChild(filler);
        tbody.appendChild(gr);

        grp.events.forEach(evt => {
          const row = document.createElement('tr');
          row.className = 'event-row';

          const nameTd = document.createElement('td');
          nameTd.className = 'sticky-col';
          const nameDiv = document.createElement('div');
          nameDiv.className = 'event-name';
          nameDiv.textContent = (uiLang === 'en' ? evt.name_en : evt.name);
          nameTd.appendChild(nameDiv);
          row.appendChild(nameTd);

          const cells = [];
          for (let i = 0; i < totalDays; i++) {
            const td = document.createElement('td');
            td.className = 'grid-cell';
            row.appendChild(td);
            cells.push(td);
          }
          tbody.appendChild(row);

          const occs = getOccurrences(evt, rangeStartJST, rangeEndJST);

          occs.forEach(occ => {
            // Convert occurrence start time to selected timezone for positioning
            const startInTZ = getDatePartsInTZ(occ.start, tz);
            const endInTZ = getDatePartsInTZ(occ.end, tz);

            const y = startInTZ.year;
            const m = startInTZ.month;
            const d = startInTZ.day;
            const startIdx = gridIndexForYMD(y, m, d);
            if (startIdx < 0) return;

            // Calculate position based on timezone-adjusted time
            const mins = startInTZ.hour * 60 + startInTZ.minute;
            const leftPct = (mins / 1440) * 100;
            
            // Calculate duration in the selected timezone
            const durMs = occ.end - occ.start;
            const widthPct = (durMs / 86400000) * 100;

            const bar = document.createElement('div');
            bar.className = 'event-bar';
            bar.style.background = evt.color;
            bar.style.left = `${leftPct}%`;
            bar.style.width = `calc(${widthPct}% - 1px)`;

            bar.dataset.name = (uiLang === 'en' ? evt.name_en : evt.name);
            bar.dataset.start = formatInTZ(occ.start, tz);
            bar.dataset.end = formatInTZ(occ.end, tz);

            bar.addEventListener('pointerenter', (e) => {
              if (e.pointerType === 'mouse' && !tooltipPinned) showTooltipForBar(bar);
            });
            bar.addEventListener('pointerleave', (e) => {
              if (e.pointerType === 'mouse' && !tooltipPinned) tooltipEl.style.opacity = '0';
            });
            bar.addEventListener('pointerdown', (e) => {
              e.preventDefault();
              tooltipPinned = true;
              showTooltipForBar(bar);
            }, { passive: false });

            cells[startIdx].style.overflow = 'visible';
            cells[startIdx].appendChild(bar);
          });
        });
      });

      updateTimeline();
    }

    function goToNow() {
      const parts = getTZParts(tzSelect.value);
      render();

      setTimeout(() => {
        updateTimeline();
        
        const cell = document.querySelector(`.date-cell[data-y="${parts.year}"][data-m="${parts.month}"][data-d="${parts.day}"]`);
        
        if (cell && timeline.style.display !== 'none') {
          const cellLeft = cell.offsetLeft;
          const cellWidth = cell.offsetWidth;
          
          const seconds = parts.hour * 3600 + parts.minute * 60 + parts.second;
          const progress = seconds / 86400;
          const exactPosition = cellLeft + (cellWidth * progress);
          
          const targetScroll = exactPosition - (viewport.clientWidth / 2);
          
          viewport.scrollTo({
            left: Math.max(0, targetScroll),
            behavior: 'smooth'
          });
        }
      }, 200);
    }

    document.getElementById('langBtn').addEventListener('click', () => {
      uiLang = (uiLang === 'ja') ? 'en' : 'ja';
      localStorage.setItem(LS_LANG, uiLang);
      tooltipEl.style.opacity = '0';
      tooltipPinned = false;
      applyUIText();
      render();
    });

    tzSelect.addEventListener('change', () => {
      localStorage.setItem(LS_TZ, tzSelect.value);
      tooltipEl.style.opacity = '0';
      tooltipPinned = false;
      render();
    });

    document.getElementById('nowBtn').addEventListener('click', goToNow);

    viewport.addEventListener('scroll', () => {
      if (timeline.style.display !== 'none') updateTimeline();
    }, { passive: true });

    applyUIText();
    goToNow();
    setInterval(updateTimeline, 30 * 1000);
  </script>
</body>
</html>
